
# 안녕 넘파이🖐

Numpy(넘파이)는 파이썬에서의 빠르고 쉬운 배열연산을 위해 만들어진 라이브러리입니다. `import numpy as np`로 불러옵니다.

## 기본 사용법

### 새 배열 만들기

```python
arr1 = np.array([1,2,3,4,5]) # np.array의 인자로 반복가능한 객체(Iterable)를 넘겨줍니다.
print(arr1)
# array([1, 2, 3, 4, 5])

# 다차원 배열을 만들 수 있습니다.
arr2 = np.array([[1, 2, 3], [4, 5, 6]]) # 2x3 배열
print(arr2)
# array([[1, 2, 3],
#       [4, 5, 6]])

# 다차원배열의, 각 차원 배열의 요소 수는 같아야합니다.
# 아래는 2차원 넘파이 배열이 아닌, 리스트를 요소로 가지는 1차원 넘파이 배열
np.array([[1, 2, 3], [1, 2]])
# array([list([1, 2, 3]), list([1, 2])], dtype=object)
```

### 배열의 정보 확인하기

```python
print(arr2.shape) # (2, 3)
# shape 속성으로 다차원배열의 모양을 알 수 있습니다, 튜플을 반환
# 2x3 배열의 2차원배열이라는 뜻!

print(arr2.ndim) # 2
# ndim 속성으로 배열의 차원수를 알 수 있습니다.

print(arr2.dtype) # 배열에 담긴 데이터가 어떤 자료형인지?
# -> 정수형: int64 (뒤에 오는 숫자는 달라질 수 있음)
# -> 실수형: float64 (뒤에 오는 숫자는 달라질 수 있음)
# -> 문자열: <U + 문자열 최대 길이 ("<U3", "<U12" 등..)

print(len(arr2)) # 배열의 길이를 알 수 있다
```

### 연산

```python
print(arr1 + 1) # array([2, 3, 4, 5, 6])
# arr1의 모든 원소에 1을 더한다

print(arr1 * 2) array([ 2,  4,  6,  8, 10])
# arr1의 모든 원소에 2를 곱한다

```

```python
np.array([1, 2, 3]) + np.array([4, 5, 6]) # array([5, 7, 9])
np.array([1, 2, 3]) * np.array([4, 5, 6]) # array([ 4, 10, 18])
# 인덱스가 같은 각 원소에 대해 연산을 수행합니다

```

## 연산 메소드

### Sum, Mean, Min, Max : 합,평균, 최소, 최대

```python
arr = np.array([1, 2, 3, 4, 5, 6])
arr.sum() # 12
arr.mean() # 3.5
# Float로 반환됩니다!!
arr.min() # 1
arr.max() # 6
```

## 난수 메소드

### random.rand : 랜덤한 다차원 배열

```python
np.random.rand(3, 3)
# array([[0.10099161, 0.93523944, 0.43638527],
#        [0.79024179, 0.74439626, 0.98137161],
#        [0.70867203, 0.03523166, 0.66176346]])
# 0~1의 랜덤한 실수로 채워진 3x3의 배열 만들기

# np.random.rand(3, 3, 4)

```

### random.randint : 랜덤한 양의 정수 혹은 다차원 배열

```python
# np.random.randint([최솟값 = 0], 최댓값, [size=배열모양 : int | int tuple])
# size 속성이 주어진다면 배열을 반환하고, 아니면 정수를 반환합니다

np.random.randint(10, 100, size=(2, 3))
# array([[38, 51, 66],
#        [87, 70, 76]])
# 최솟값이 10, 최댓값이 100인 2x3배열 랜덤한 배열

np.random.randint(100, size=10)
# array([75, 48, 31,  3,  4, 10,  0, 92, 99, 90])
# 최댓값이 100이고 요소가 10개인 랜덤한 배열

np.random.randint(10, 100)
# 32
# 최솟값이 10, 최댓값이 100인 랜덤한 정수

```

### random.randn : 랜덤한 실수의 다차원배열
```python
np.random.randn(2) # array([-0.2018373 , -0.30949003])
# 가우시안 표준 정규 분포 난수를 요소로 가지는 길이가 2인 배열

np.random.randn(2, 3)
# array([[ 1.01961919,  0.62031195,  1.32018115],
#        [ 0.65679459,  0.49923583, -0.05213526]])
# 가우시안 표준 정규 분포 난수를 요소로 가지는 2x3의 배열
```
가우시안 표준 정규 분포 난수 : 평균 0, 표준편차가 1인 난수들. 이론적으로는 무수히 많은 난수를 모두 더하면 0이 된다.



## 생성 메소드

### reshape : 모양 재구성
```python
arr.reshape(1, 6) # array([[1, 2, 3, 4, 5, 6]])
# 1x6로 재구성

arr.reshape(2, 3)
#array([[1, 2, 3],
#       [4, 5, 6]])
# 2x3로 재구성

arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr1.reshape(9) # array([1, 2, 3, 4, 5, 6, 7, 8, 9])

```

### arange : 등차수열
**중요: 어레인지가 아님 에이레인지임!!"
```python
# np.arange([시작값 = 0], 끝값, [증가량 = 1], [타입 = int])
np.arange(15) # array([0, 1, 2, ..., 13, 14])
np.arange(3, 16, 5, float) # array([ 3.,  8., 13.])
# 3부터 16까지 5만큼 증가하며 타입은 float인 배열을 만든다

np.arange(0, 15, 3) # array([ 0,  3,  6,  9, 12])
# 단! 끝값은 배열에 포함되지 않음!!

```

### dot : 행렬곱
![행렬곱을 설명하는 이미지](/assets/npdot.jpg)
( 조원진님 고맙습니다 :) )

```python
np.dot
	np.array([[1, 2], [3, 4], [5, 6]]),
  np.array([7, 11])
) # array([ 29,  65, 101])

```

### zeros / ones : 0 / 1으로 채워진 배열 생성

```python
# np.zeros(요소 갯수: int | tuple, [타입 = int])
# ones도 동일
np.zeros(10, int) # array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# 정수 0으로 채워진, 길이가 10인 배열
np.zeros((2, 3))
# array([[0., 0., 0.],
#        [0., 0., 0.]])
# 실수 0으로 채워진 2x3 배열

np.ones((2, 3))
# array([[0., 0., 0.],
#        [0., 0., 0.]])
# 실수 1로 채워진 2x3 배열
```
## 기타
### View / Copy / base
View는 원본 배열을 참조하는 새 배열을 만들어요. C의 포인터같이 동작하는데, 참조하는 배열의 값이 변경되면 원본 배열도 똑같이 변경되고, 원본배열이 변경되면 참조배열에도 변경이 반영됩니다. 실제 메모리 주소는 같지 않지만, 넘파이 내부적으로는 연결이 되아있어요.
```python
a = np.array([1, 2, 3])
b = a.view()
print(a, b)
b[0] = 10
print(a, b)
#a, b가 동일함을 알 수 있다.
```
Copy는 원본 배열을 참조하지 않고 **복사**하여 새 배열을 만듭니다.
```python
a = np.array([1, 2, 3])
b = a.copy()
print(a, b)
b[0] = 10
print(a, b)
# a, b의 값이 다름
```
View를 통해 다른 배열을 참조하고 있는 배열은, `base` 프로퍼티에 원본 배열을 가리키고 있습니다.
```python
a = np.array([1, 2, 3])
b = a.view()
print(id(b.base), id(a))
# 메모리 주소가 같다
```
### nditer
다차원 배열의 모든 원소를 원소로 하는 1차원 배열. `reshape(arr.size)`과 같습니다. 주로 for문에 돌릴때 사용함!
```python
a = np.array([[10, 20, 30], [1, 2, 3]])
for i in np.nditer(a):
	print(i) # a의 모든 원소들을 출력함
```

### where
배열에서 조건에 해당하는 인덱스를 배열튜플로 반환합니다.
```python
a = np.array([[1, 3, 5, 7], [2, 4, 6, 8]])
np.where(a <=  3)
# (array([0, 0, 1]), array([0, 1, 0]))
# [0, 0], [0, 1], [1, 0]번 원소라는 뜻
np.where(a[0] <=  3)
# (array([0, 1]),)
# 0번째, 1번째 원소라는 뜻
```# 안녕 넘파이🖐

Numpy(넘파이)는 파이썬에서의 빠르고 쉬운 배열연산을 위해 만들어진 라이브러리입니다. `import numpy as np`로 불러옵니다.

## 기본 사용법

### 새 배열 만들기

```python
arr1 = np.array([1,2,3,4,5]) # np.array의 인자로 반복가능한 객체(Iterable)를 넘겨줍니다.
print(arr1)
# array([1, 2, 3, 4, 5])

# 다차원 배열을 만들 수 있습니다.
arr2 = np.array([[1, 2, 3], [4, 5, 6]]) # 2x3 배열
print(arr2)
# array([[1, 2, 3],
#       [4, 5, 6]])

# 다차원배열의, 각 차원 배열의 요소 수는 같아야합니다.
# 아래는 2차원 넘파이 배열이 아닌, 리스트를 요소로 가지는 1차원 넘파이 배열
np.array([[1, 2, 3], [1, 2]])
# array([list([1, 2, 3]), list([1, 2])], dtype=object)
```

### 배열의 모양 확인하기

```python
print(arr2.shape) # (2, 3)
# shape 속성으로 다차원배열의 모양을 알 수 있습니다, 튜플을 반환
print(arr2.ndim) # 2
# ndim 속성으로 배열의 차원수를 알 수 있습니다.
# 이거 좀 중요하게 말하심! 알아두는게 좋음!

# 2x3 배열의 2차원배열이라는 뜻!
```

### 연산

```python
print(arr1 + 1) # array([2, 3, 4, 5, 6])
# arr1의 모든 원소에 1을 더한다

print(arr1 * 2) array([ 2,  4,  6,  8, 10])
# arr1의 모든 원소에 2를 곱한다

```

```python
np.array([1, 2, 3]) + np.array([4, 5, 6]) # array([5, 7, 9])
np.array([1, 2, 3]) * np.array([4, 5, 6]) # array([ 4, 10, 18])
# 인덱스가 같은 각 원소에 대해 연산을 수행합니다

```

## 연산 메소드
`sum`, `min`, `max`, `mean`은 ndarray 객체의 메소드로 바로 사용할 수 있지만(`arr.sum()` 가능), median, std는 넘파이 모듈의 메소드로만 사용해야 합니다(`np.sum(arr)`).
```python
arr = np.array([1, 2, 3, 4, 5, 6])
arr.sum() # 12, np.sum(arr) 가능
arr.min() # 1
arr.max() # 6

arr.mean() # 평균 3.5
np.median(arr) # 중앙값 3.5
np.std(arr) # 표준편차 1.707825127659933
# Float로 반환됩니다!!
# arr.median() 불가능!
```
### 계산 방향 지정(Axis)
다차원 배열에서 연산메소드를 수행할 축 방향을 지정할 수 있다.
```python
arr = np.array([
	[1, 2, 3],
	[4, 5, 6]
])

arr.sum(axis=1)
# axis가 1이면?
# 배열의 1번째 인덱스 차원을 더함 (인덱스는 0부터 시작)
# arr의 shape가 (3, 2)이기 때문에, 1번째 인덱스인 행에 대해 연산을 수행하고
# 행의 갯수는 2개이기에, 2개의 값이 나올것
# 결과: [6, 15]

arr.sum(axis=0)
# axis는 0이고, 0번째 인덱스 차원(열)을 더한다.
# 열의 갯수는 3개이기 때문에, 3개의 값이 나온다
# 결과: [5, 7, 9]
```

## 난수 메소드

### random.rand : 랜덤한 다차원 배열

```python
np.random.rand(3, 3)
# array([[0.10099161, 0.93523944, 0.43638527],
#        [0.79024179, 0.74439626, 0.98137161],
#        [0.70867203, 0.03523166, 0.66176346]])
# 0~1의 랜덤한 실수로 채워진 3x3의 배열 만들기

# np.random.rand(3, 3, 4)

```

### random.randint : 랜덤한 양의 정수 혹은 다차원 배열

```python
# np.random.randint([최솟값 = 0], 최댓값, [size=배열모양 : int | int tuple])
# size 속성이 주어진다면 배열을 반환하고, 아니면 정수를 반환합니다

np.random.randint(10, 100, size=(2, 3))
# array([[38, 51, 66],
#        [87, 70, 76]])
# 최솟값이 10, 최댓값이 100인 2x3배열 랜덤한 배열

np.random.randint(100, size=10)
# array([75, 48, 31,  3,  4, 10,  0, 92, 99, 90])
# 최댓값이 100이고 요소가 10개인 랜덤한 배열

np.random.randint(10, 100)
# 32
# 최솟값이 10, 최댓값이 100인 랜덤한 정수

```

### random.randn : 랜덤한 실수의 다차원배열
```python
np.random.randn(2) # array([-0.2018373 , -0.30949003])
# 가우시안 표준 정규 분포 난수를 요소로 가지는 길이가 2인 배열

np.random.randn(2, 3)
# array([[ 1.01961919,  0.62031195,  1.32018115],
#        [ 0.65679459,  0.49923583, -0.05213526]])
# 가우시안 표준 정규 분포 난수를 요소로 가지는 2x3의 배열
```
가우시안 표준 정규 분포 난수 : 평균 0, 표준편차가 1인 난수들. 이론적으로는 무수히 많은 난수를 모두 더하면 0이 된다.

## 생성 메소드

### reshape : 모양 재구성
**강조하심**
```python
arr.reshape(1, 6) # array([[1, 2, 3, 4, 5, 6]])
# 1x6로 재구성

arr.reshape(2, 3)
#array([[1, 2, 3],
#       [4, 5, 6]])
# 2x3로 재구성

arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr1.reshape(9) # array([1, 2, 3, 4, 5, 6, 7, 8, 9])

```

### arange : 등차수열

```python
# np.arange([시작값 = 0], 끝값, [증가량 = 1], [타입 = int])
np.arange(15) # array([0, 1, 2, ..., 13, 14])
np.arange(3, 16, 5, float) # array([ 3.,  8., 13.])
# 3부터 16까지 5만큼 증가하며 타입은 float인 배열을 만든다

np.arange(0, 15, 3) # array([ 0,  3,  6,  9, 12])
# 단! 끝값은 배열에 포함되지 않음!!

```

### dot : 행렬곱
> <- 행렬 안나옴..?!!ㄴㅇㅅㄴㅇㅅ

![행렬곱을 설명하는 이미지](/assets/npdot.jpg)
( 조원진님 고맙습니다 :) )

디스이즈 행렬곱! 중요하다.

```python
np.dot
	np.array([[1, 2], [3, 4], [5, 6]]),
  np.array([7, 11])
) # array([ 29,  65, 101])

```

### zeros / ones : 0 / 1으로 채워진 배열 생성

```python
# np.zeros(요소 갯수: int | tuple, [타입 = int])
# ones도 동일
np.zeros(10, int) # array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# 정수 0으로 채워진, 길이가 10인 배열
np.zeros((2, 3))
# array([[0., 0., 0.],
#        [0., 0., 0.]])
# 실수 0으로 채워진 2x3 배열

np.ones((2, 3))
# array([[0., 0., 0.],
#        [0., 0., 0.]])
# 실수 1로 채워진 2x3 배열
```
## 기타
### View / Copy / base
View는 원본 배열을 참조하는 새 배열을 만들어요. C의 포인터같이 동작하는데, 참조하는 배열의 값이 변경되면 원본 배열도 똑같이 변경되고, 원본배열이 변경되면 참조배열에도 변경이 반영됩니다. 실제 메모리 주소는 같지 않지만, 넘파이 내부적으로는 연결이 되아있어요.
```python
a = np.array([1, 2, 3])
b = a.view()
print(a, b)
b[0] = 10
print(a, b)
#a, b가 동일함을 알 수 있다.
```
Copy는 원본 배열을 참조하지 않고 **복사**하여 새 배열을 만듭니다.
```python
a = np.array([1, 2, 3])
b = a.copy()
print(a, b)
b[0] = 10
print(a, b)
# a, b의 값이 다름
```
View를 통해 다른 배열을 참조하고 있는 배열은, `base` 프로퍼티에 원본 배열을 가리키고 있습니다.
```python
a = np.array([1, 2, 3])
b = a.view()
print(id(b.base), id(a))
# 메모리 주소가 같다
```
### nditer
다차원 배열의 모든 원소를 원소로 하는 1차원 배열. `reshape(arr.size)`과 같습니다. 주로 for문에 돌릴때 사용함!
```python
a = np.array([[10, 20, 30], [1, 2, 3]])
for i in np.nditer(a):
	print(i) # a의 모든 원소들을 출력함
```

### where
배열에서 조건에 해당하는 인덱스를 배열튜플로 반환합니다.
```python
a = np.array([[1, 3, 5, 7], [2, 4, 6, 8]])
np.where(a <=  3)
# (array([0, 0, 1]), array([0, 1, 0]))
# [0, 0], [0, 1], [1, 0]번 원소라는 뜻
np.where(a[0] <=  3)
# (array([0, 1]),)
# 0번째, 1번째 원소라는 뜻
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0NzQxNzMzODUsLTEyMzU5MjA2MjEsLT
gwNzkwNjgxNSw5NjkyNzkzODZdfQ==
-->