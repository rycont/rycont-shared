<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RyCont Shared</title>
    <link rel="stylesheet" href="/assets/colorcode.css">
    <link rel="stylesheet" href="/assets/style.css">
</head>

<body>
    <nav>
        <a href="/">
            <img src="/assets/logo.svg" alt="rycont logo">
            <span>RyCont Shared</span>
        </a>
    </nav>
    <div class="breadcrumb">
        <div id="location">

        </div>
        <a href="" id="github">
            <div>
                <img src="/assets/github.svg">
                <span>
                    GitHub에서 보기
                </span>
            </div>
        </a>
    </div>
    <article id="content">
        <h2 id="selection-sort-선택정렬">Selection Sort 선택정렬</h2>
<ul>
<li>제자리 정렬</li>
<li>배열의 인덱스를 순회하며 인덱스과 인덱스 이후까지 배열의 최솟값을 교환하며, 최종적으로는 범위별 최솟값이 차곡차곡 쌓여서 오름차순 정렬됨</li>
<li>시간복잡도 O(n^2)</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">selection</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
   <span class="token comment">// i는 배열에서 현재 진행중인 인덱스를 나타냅니다.</span>
   <span class="token comment">// j는 현재 비교중인 인덱스를 나타냅니다.</span>
   <span class="token comment">// 포문에서 함께 선언할 수 있었지만 그렇게 하지 않은 이유는 딱히 없습니다...</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// i를 0부터 n - 1까지 순회합니다.</span>
      <span class="token comment">// 즉, 배열의 모든 인덱스에서 마지막 하나만 남기고 모두 순회합니다.</span>
      <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 최솟값의 인덱스를 지정합니다. 초기값은 현재 인덱스로 지정합니다.</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
         <span class="token comment">// j를 i의 다음번째부터 배열의 끝원소까지 반복합니다.</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span>
            min <span class="token operator">=</span> j<span class="token punctuation">;</span>
         <span class="token comment">// j번째 원소가 최솟값보다 작다면 최솟값의 인덱스를 갱신합니다</span>
      <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 최솟값과 현재 진행중인 인덱스를 교환합니다.</span>
      <span class="token comment">// 따라서 i번째 인덱스에는 항상 그 이후보다 작은 값이 저장되고,</span>
      <span class="token comment">// 순차적으로 정렬됩니다.</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<h2 id="bubble-sort-버블거품-정렬">Bubble Sort 버블/거품 정렬</h2>
<ul>
<li>제자리 정렬</li>
<li>배열의 각 인덱스를 순회하며 인접한 원소들 둘중 더 큰 원소가 뒤에 오도록 교환합니다. 계속 반복하다가 모두 정렬이 되면 종료합니다.</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">bubble</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/*
         변경사항이 없다면, 즉 정렬이 완료되면
          k가 초기값(n - 1)과 같아짐으로
         위 반복문을 빠져나오게 된다.
      */</span> 
      <span class="token keyword">int</span> j<span class="token punctuation">;</span>                           <span class="token comment">// 비교할 인덱스를 담는 변수</span>
      <span class="token keyword">int</span> last <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 바뀐 뒷번째 인덱스를 담는 변수.</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token number">-1</span><span class="token punctuation">;</span> j<span class="token operator">&gt;</span>k<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>             <span class="token comment">// j는 원소의 마지막부터 k까지 역순으로 순회한다</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// j번째와 그 앞 원소를 비교했을 때 앞것이 더 크면</span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// j와 그 앞원소를 교환</span>
            last <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token comment">/*
            교환이 일어난 인덱스를 기록.
            for문을 돌면서 여러번 기록이 되며
            for문이 끝나면 최종적으로는 교환이 일어난
            가장 앞번째 인덱스가 저장됨.
            */</span>
         <span class="token punctuation">}</span>
      k <span class="token operator">=</span> last<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="insertion-sort-삽입정렬">Insertion Sort 삽입정렬</h2>
<p>Insertion Sort 삽입정렬</p>
<ul>
<li>제자리 정렬</li>
<li>배열 인덱스를 순회하며 인덱스 앞부분(0 ~ i) 배열에 값을 순서대로 삽입하여 끝까지 순회가 끝나면 결국 오름차순으로 정렬된다.</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">insertion</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment">// i는 현재 정렬중인 인덱스, j는 이따가 쓸 반복문 변수</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1번째 인덱스부터 순회.</span>
      <span class="token comment">// 0번은 비교할 앞원소가 없기에 1번째부터!</span>

      <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">/*
         현재 정렬중인 값을 잠깐 담아둘 공간.
         배열을 오른쪽으로 한칸씩 밀거기 때문에
         이 시점의 i번재 원소는 곧 사라질 예정
      */</span>

      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
         a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
         <span class="token comment">/*
            이게 대체 무슨 반복문이냐? 살펴봅시다
            1. j는 i부터 시작한다. i는 현재 정렬중인 인덱스이다.
            2. j가 유효한 범위인동안 반복할거다.
               j가 0보다 크고, j의 바로 앞 원소가
               tmp(현재 정렬중인 값)보다 클 동안.
            3. j를 하나씩 줄일것이다.
            
            위와 같은 단계를 거치고 나면,
            다음과 같은 2개의 케이스가 발생할 수 있다.
            1. `j&lt;0` 조건이 거짓이 되는것
               이는 현재 정렬중인 값이 배열의 최솟값이라는 의미가 된다.
               즉, 반복문 종료 후 j는 0이 되어서
               0번 인덱스에 정렬중인 값이 들어갈것.
            2. `a[j - 1] &gt; tmp` 조건이 거짓이 되는것
               이는 앞원소보다는 현재 정렬중인 값이
               j 인덱스에 삽입될 경우, 앞 원소보다는
               크다는것을 의미한다. 또한 이전 포문에 의해서
               다음 (j + 1)번째 원소보다는 작거나 같다는 것이
               검증되었기 때문에, 이는 올바른 위치라고 추측할 수 있다.
         */</span>
      a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
      <span class="token comment">// 위의 포문을 통해 구한 j 위치에 현재 정렬중인 값을 대입한다.</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<div id="disqus_thread"></div>
        <script>
            /**
            *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
            *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
            /*
            var disqus_config = function () {
            this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
            };
            */
            (function () { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://rycont-shared.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </article>
    <script src="/assets/script.js"></script>
</body>

</html>
