## Merge Sort 병합정렬
- 합병정렬이라고도 불림
- 제자리정렬 아님
- 분할정복법
- 배열을 잘게 쪼개고, 붙히는데, 붙히는 과정에서 원소의 크기 비교를 하며 정렬을 한다
- 진짜 어려워요. 특히 호선쌤 코드가 일반적이지 않아서.. 더 이해하기 힘들 수 있어요. 그렇지만 포기하지 말기!
- 이거만 이해하면 진짜 정렬 마스터..까지는 아니라도 "나 알고리즘 좀 배웠어~" 할 수 있음!

![10, 8, 6, 20, 4, 3, 22, 1, 0, 5, 16을 분할정복법을 활용한 병합정렬하는 과정.](/assets/divideconquer.png)
오 조금 난해한데요.
호선쌤의 코드는 병합정렬을 재귀함수로 풀이했습니다! 그렇지만 재귀를 쓰지 않고도 구현할 수 있다는 점을 알아두세요.
```c
static int *buff;
/*
    정렬되면서 임시로 들어갈 값들이
    저장될 곳. 배열의 크기가 얼마나 될지
    몰라서 이후에 동적으로 할당해준다
*/
static void __mergeSort(int a[], int left, int right) {
    /*
        함수 선언에 static이 붙은 이유는.. "없음!"
        있어도 되고 없어도 되는데 딱히 이 코드에서는
        영향을 주지 않기 때문에 신경 쓰지 않아도 됨 :)
    */

    if (left < right) {
        /*
            왼쪽이 오른쪽보다 작은동안 반복합니다.
            if문인데 왜 반복이라고 하냐? 재귀문이기 때문.
            left가 right보다 작지 않을경우는
            left와 right가 같을 때 밖에 없음.
            이는 하나의 원소로 모조리 분할된것,
            따라서 추가적인 동작을 하지 않는다.
        */
        int center = (left + right) / 2;
        int p = 0; // 버퍼에 삽입중인 원소 인덱스
        int i; // 버퍼에 삽입중인 원소의 원본배열 인덱스
        /*
			그니까 저게 무슨 뜻이냐..
			p는 버퍼의 몇번 인덱스에 삽입중이냐?
			i는 몇번 원소를 버퍼에 삽입중이냐?
			이겁니다..ㅜ
		*/
        int j = 0; // 버퍼에서 비교중인 인덱스. 이후 "배열의 왼쪽 부분"에서 비교중인 인덱스를 가리킬것.
        int k = left; // 원본배열에서 비교중인 인덱스. 이후 "배열의 오른쪽 부분"에서 비교중인 인덱스를 가리킬것.

        __mergeSort(a, left, center);
        __mergeSort(a, center + 1, right);
        /*
            현재 왼쪽을 새 왼쪽으로, 현재 가운데를 오른쪽으로 하는 부분과
            현재 가운데+1을 새 왼쪽으로, 현재 오른쪽을 새오른쪽으로 하는 부분을 만들면
            대략적이게 배열을 반갈죽하게된다.
            왜 대략적이나면, 왼쪽은 left부터 center를 가지고, 오른쪽은 center + 1부터 right를 가지기 때문에,
            왼쪽이 오른쪽보다 항상 1개 많거나 같기 때문!
            배열의 길이가 홀수일 때에 왼쪽이 더 길어진다
        */

        // 여기부터가 진짜 소트 과정이다
        for (i = left; i <= center; i++)
            buff[p++] = a[i];
            /*
                일단 버퍼에 왼쪽절반을 밀어넣는다.
                p가 0으로 초기화됐었기에, left부터 center까지 진행하면서
                차곡차곡 넣게 된다.
                주의해야할점은 포문이 끝나도 i가 사라지지 않고
                center값으로 남아있다는 점!
                또한 p는 왼쪽 배열의 길이로 남게된다.
            */

        while (i <= right && j < p)
            /*
                i는 오른쪽부분에서 합병중인 인덱스를 나타내는데 아래 코드에서 쓰이고 있다.
                &&의 좌변인 `i <= right`는 오른쪽부분 인덱스가 오른쪽 부분의 범위를 넘는지 검사하고,
                우변인 `j < p`는 왼쪽부분 인덱스가 왼쪽부분의 범위를 넘지 않는지 검사한다.
            */
            a[k++] = (buff[j] <= a[i]) ? buff[j++] : a[i++];
            /*
                여기가 핵심!
                삼항연산자가 헷갈린다면 1학기를 되돌아보기..
                삼항연산자에 따르면, 두가지 케이스로 분류가 될 수 있음
                1. buff[j], 즉 왼쪽에 들어있는 값이 더 큰 경우
                2. a[i++], 오른쪽 값이 더 큰 경우
                1번의 경우로 예시를 들어봅시다
                
                buff[j++]가 a[k++]에 대입되게 되는데
                이는 세가지 연산으로 분리될 수 있다.
                - a[k]에 buff[j]를 대입한다
                    j는 버퍼(왼쪽)에서 비교중인 인덱스를 담고 있고,
                    k는 배열의 오른쪽 부분에서 비교중인 인덱스를 담고 있다.
                    즉 현재 버퍼에서 비교중인 값이
                    배열로 들어간다.
                - j에 1을 증가
                - k에 1을 증가
                    왼쪽에서 비교중인 인덱스를 하나 늘려서 다음 원소 비교하도록 하고,
                    오른쪽도 마찬가지로 인덱스 증가.
                여기서 의문이 생길 수 있음. a[k++]의 과정에서 오른쪽 배열의 값이 덮어씌워져서
                올바르게 비교가 이루어지지 않을것같은데?
                그렇지만 절대로 k가 i보다 커질 수 없음.
                k는 시작값이 left이고, 한 비교 사이클당 1씩 증가함
                i는 시작값이 center이고, 사이클당 50% 확률로(오른쪽이 클때만) 1씩 증가함
                이거 살짝 그 빨리 달리는 아킬레스 역설이랑 비슷함
                그렇지만 최댓값이 둘 다 right이기 때문에, i가 항상 k보다 크거나 같음
                언제 같아지느냐? 오른쪽 배열의 마지막 원소가 왼쪽 오른쪽 통틀어서 최대값일 때에.
                그렇지만 그 때가 되어서는 둘이 같은 인덱스를 가리켜도 원소는 하나밖에 남지 않았기에
                최종적으로는 올바르게 정렬을 마치게 된다.
            */

        while (j < p)
            // 왼쪽 부분에 값이 남아 있나면?? 전체 배열에 마저 밀어넣어준다
            // 왜 왼쪽 부분만 검사하느냐? 위에 다시 보고 오세요..
            a[k++] = buff[j++];
    }
}
int mergesort(int a[], int n) {
    if ((buff = calloc(n, sizeof(int))) == NULL)
        // 늘 쓰던 코드! 배열의 갯수로 동적할당해준다.
        return -1;
    __mergeSort(a, 0, n - 1);
    // 재귀호출의 시작점
    free(buff);
    // 정렬이 끝나고 임시배열을 제거해준다.
    return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYxMjI3MjE2NF19
-->