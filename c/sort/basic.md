## Selection Sort 선택정렬
-  제자리 정렬
-  배열의 인덱스를 순회하며 인덱스과 인덱스 이후까지 배열의 최솟값을 교환하며, 최종적으로는 범위별 최솟값이 차곡차곡 쌓여서 오름차순 정렬됨
- 시간복잡도 O(n^2)
```c
void selection(int a[], int n) {
   int i, j;
   // i는 배열에서 현재 진행중인 인덱스를 나타냅니다.
   // j는 현재 비교중인 인덱스를 나타냅니다.
   // 포문에서 함께 선언할 수 있었지만 그렇게 하지 않은 이유는 딱히 없습니다...
   for (i = 0; i < n - 1; i++) {
      // i를 0부터 n - 1까지 순회합니다.
      // 즉, 배열의 모든 인덱스에서 마지막 하나만 남기고 모두 순회합니다.
      int min = i; // 최솟값의 인덱스를 지정합니다. 초기값은 현재 인덱스로 지정합니다.
      for (j = i + 1; j < n; j++)
         // j를 i의 다음번째부터 배열의 끝원소까지 반복합니다.
         if (a[j] < a[min])
            min = j;
         // j번째 원소가 최솟값보다 작다면 최솟값의 인덱스를 갱신합니다
      swap(int, a[i], a[min]);
      // 최솟값과 현재 진행중인 인덱스를 교환합니다.
      // 따라서 i번째 인덱스에는 항상 그 이후보다 작은 값이 저장되고,
      // 순차적으로 정렬됩니다.
   }
}

```

## Bubble Sort 버블/거품 정렬
- 제자리 정렬
- 배열의 각 인덱스를 순회하며 인접한 원소들 둘중 더 큰 원소가 뒤에 오도록 교환합니다. 계속 반복하다가 모두 정렬이 되면 종료합니다.
```c
void bubble(int a[], int n) {
   int k = 0;
   while (k < n - 1) {
      /*
         변경사항이 없다면, 즉 정렬이 완료되면
          k가 초기값(n - 1)과 같아짐으로
         위 반복문을 빠져나오게 된다.
      */ 
      int j;                           // 비교할 인덱스를 담는 변수
      int last = n - 1;                // 바뀐 뒷번째 인덱스를 담는 변수.
      for(j=n-1; j>k; j--)             // j는 원소의 마지막부터 k까지 역순으로 순회한다
         if (a[j - 1] > a[j]) {        // j번째와 그 앞 원소를 비교했을 때 앞것이 더 크면
            swap(int, a[j - 1], a[j]); // j와 그 앞원소를 교환
            last = j;
            /*
            교환이 일어난 인덱스를 기록.
            for문을 돌면서 여러번 기록이 되며
            for문이 끝나면 최종적으로는 교환이 일어난
            가장 앞번째 인덱스가 저장됨.
            */
         }
      k = last;
   }
}
```
## Insertion Sort 삽입정렬
Insertion Sort 삽입정렬
- 제자리 정렬
- 배열 인덱스를 순회하며 인덱스 앞부분(0 ~ i) 배열에 값을 순서대로 삽입하여 끝까지 순회가 끝나면 결국 오름차순으로 정렬된다.
```c
void insertion(int a[], int n) {
   int i, j; // i는 현재 정렬중인 인덱스, j는 이따가 쓸 반복문 변수
   for (i = 1; i < n; i++) {
      // 1번째 인덱스부터 순회.
      // 0번은 비교할 앞원소가 없기에 1번째부터!

      int tmp = a[i];
      /*
         현재 정렬중인 값을 잠깐 담아둘 공간.
         배열을 오른쪽으로 한칸씩 밀거기 때문에
         이 시점의 i번재 원소는 곧 사라질 예정
      */

      for (j = i; j > 0 && a[j - 1] > tmp; j--)
         a[j] = a[j - 1];
         /*
            이게 대체 무슨 반복문이냐? 살펴봅시다
            1. j는 i부터 시작한다. i는 현재 정렬중인 인덱스이다.
            2. j가 유효한 범위인동안 반복할거다.
               j가 0보다 크고, j의 바로 앞 원소가
               tmp(현재 정렬중인 값)보다 클 동안.
            3. j를 하나씩 줄일것이다.
            
            위와 같은 단계를 거치고 나면,
            다음과 같은 2개의 케이스가 발생할 수 있다.
            1. `j<0` 조건이 거짓이 되는것
               이는 현재 정렬중인 값이 배열의 최솟값이라는 의미가 된다.
               즉, 반복문 종료 후 j는 0이 되어서
               0번 인덱스에 정렬중인 값이 들어갈것.
            2. `a[j - 1] > tmp` 조건이 거짓이 되는것
               이는 앞원소보다는 현재 정렬중인 값이
               j 인덱스에 삽입될 경우, 앞 원소보다는
               크다는것을 의미한다. 또한 이전 포문에 의해서
               다음 (j + 1)번째 원소보다는 작거나 같다는 것이
               검증되었기 때문에, 이는 올바른 위치라고 추측할 수 있다.
         */
      a[j] = tmp;
      // 위의 포문을 통해 구한 j 위치에 현재 정렬중인 값을 대입한다.
   }
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY3NTg5MjkzM119
-->